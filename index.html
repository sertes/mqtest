<html>
<head>
    <title>MQ Test Page</title>
    <meta name="description" content="MQ test page">
    <meta name="keywords" content="mq test page">
    <meta charset="utf-8">
    <meta name="viewport" content="width=1024px, initial-scale=1">

    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
            'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
            sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /** {*/
        /*  font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;*/
        /*}*/

        * {
            box-sizing: border-box;
        }

        .container {
            display: flex;
        }

        .graph {
            padding: 5px;
            border: 1px solid gray;
            width: 480px;
            height: 320px;
        }
    </style>

</head>
<body>
<h1>Архив метеослужбы</h1>
<div class="container">
    <div class="left">
        <div><button>Температура</button></div>
        <div><button>Осадки</button></div>
    </div>
    <div class="content">
        <div class="filters">
            <select id="year_from">
                <option>1881</option>
            </select>
            <select id="year_to">
                <option>2006</option>
            </select>
        </div>
        <canvas class="graph" height="320" width="480" id="graph"></canvas>
    </div>
</div>
<div><button id="clearIDB">Clear IndexedDB</button></div>
<script>
    // import React from 'react';
    // import ReactDOM from 'react-dom';
    import './index.css';
    // import App from './App';
    //
    // ReactDOM.render(
    //   <React.StrictMode>
    //     <App />
    //   </React.StrictMode>,
    //   document.getElementById('root')
    // );


    // TODO: check every requirement from MQ
    // TODO: check against NATA rules

    ///////////////////////////////////////////////////////////////////////////////
    // CONFIGURATION
    const URL_TEMPERATURE = './temperature.json?r=' + Math.random()
    const URL_PRECIPITATION = './precipitation.json?r=' + Math.random()

    const DB_NAME = 'store'
    const TABLE_TEMPER = 'temperature'
    const TABLE_PREC = 'precipitation'
    const SELECT_TROTTLE_TIME = 180 // select boxes trottle time in milliseconds

    let myIDBInstance;

    const fetchJsonData = {}
    const fetchLoaded = {}
    fetchLoaded[TABLE_TEMPER] = false
    fetchLoaded[TABLE_PREC] = false

    let applicationMode = TABLE_TEMPER

    function trottle(f, delay) {
        let myTrottled = false, myArgs, myContext
        function trottled() {
            if (myTrottled) {
                myArgs = arguments
                myContext = this
                return
            }

            f.apply(this, arguments)
            myTrottled = true

            setTimeout(() => {
                myTrottled = false
                if (myArgs) {
                    trottled.apply(myContext, myArgs)
                    myContext = myArgs = null
                }
            }, delay)
        }
        return trottled
    }

    function fillSelect(id, min, max, selected) {
        const mySelect = document.getElementById(id)
        mySelect.length = 0
        const myFragment = document.createDocumentFragment()
        for (let i = min; i <= max; i += 1) {
            const mySelectOption = document.createElement('option')
            mySelectOption.value = mySelectOption.text = i
            myFragment.appendChild(mySelectOption)
        }
        mySelect.appendChild(myFragment)
        mySelect.value = selected
    }

    // fill year dates
    function fillYearDates(yearFrom, yearTo) {
        // TODO: make without Date object
        const myStart = Date.now()
        const myResult = []
        let myCurrentDate = new Date(yearFrom + '-01-01')
        while (myCurrentDate.getFullYear() <= yearTo) {
            myResult.push([
                myCurrentDate.getFullYear(),
                ('0' + (myCurrentDate.getMonth() + 1)).slice(-2),
                ('0' + myCurrentDate.getDate()).slice(-2)
            ].join('-'))
            myCurrentDate.setDate(myCurrentDate.getDate() + 1)
        }
        console.log('fillYearDates time: ', Date.now() - myStart, ' msec')
        return myResult
    }

    // draw graph
    function drawGraph(yearFrom, yearTo, dataObject) {
        const myGraph = document.getElementById('graph')
        const myCtx = myGraph.getContext('2d')
        myCtx.clearRect(0, 0, myGraph.width, myGraph.height)
        myCtx.strokeRect(0, 0, myGraph.width, myGraph.height)

        const myLabels = fillYearDates(yearFrom, yearTo)
        const myValuesY = {}
        const myValuesX = []

        const myPixelFactor = 1
        const myAveragingInterval = Math.round(myLabels.length / myGraph.width) * myPixelFactor

        // count min max
        let myMin = Number.NaN
        let myMax = Number.NaN
        let myAvgSum = Number.NaN
        let myCnt = 0
        const myMinMaxCount = Date.now()
        for (let i = 1; i < myLabels.length; i += 1) {
            if (i % myAveragingInterval === 0) {
                myValuesX.push(myLabels[i]);

                let myAvgValue = (myCnt !== 0) ? myAvgSum / myCnt : Number.NaN
                if (myAvgValue) {
                    myValuesY[myLabels[i]] = myAvgValue
                    myMin = Math.min(myMin, myAvgValue) || myAvgValue
                    myMax = Math.max(myMax, myAvgValue) || myAvgValue
                }

                myAvgSum = Number.NaN
                myCnt = 0
            }

            let myValue = dataObject[myLabels[i]]
            if (myValue) {
                myAvgSum = (myAvgSum) ? (myAvgSum + myValue) : myValue
                myCnt += 1
            }
        }
        console.log('minmax count time: ', Date.now() - myMinMaxCount, ' msec', 'min:', myMin, 'max:', myMax)

        //draw x axis
        myCtx.beginPath()
        myCtx.moveTo(0, getY(0))
        myCtx.lineTo(myGraph.width, getY(0))
        myCtx.stroke()

        // myCtx.font = "14px serif";
        myCtx.fillText('' + Math.round(myMax), 5, 14);
        myCtx.fillText('' + Math.round(myMin), 5, myGraph.height - 5);

        function getY(value) {
            const myStrengthFactor = myGraph.height / (myMax - myMin)
            return myGraph.height - (0 - myMin + value) * myStrengthFactor
        }

        function getX(n, count) {
            return (myGraph.width / count) * n
        }

        // let myX = 0;
        myCtx.beginPath();
        myCtx.moveTo(0, myGraph.height / 2);
        const myPlottingTime = Date.now()

        let myGapFound = true
        for (let i = 0; i < myValuesX.length; i += 1) {
            let myValue = myValuesY[myValuesX[i]]
            if(myValue) {
                if (myGapFound) {
                    // myCtx.moveTo(myX += myPixelFactor, getY(myValue))
                    myCtx.moveTo(getX(i, myValuesX.length), getY(myValue))
                    myGapFound = false
                } else {
                    myCtx.lineTo(getX(i, myValuesX.length), getY(myValue))
                    // myCtx.lineTo(myX += myPixelFactor, getY(myValue))
                }

            } else {
                myGapFound = true;
                // console.log('gap found at:', myValuesX[i])
            }
        }
        myCtx.stroke();
        console.log('plotting time: ', Date.now() - myPlottingTime, ' msec')
        console.log('TOTAL TIME ', Date.now() - myStartFetching, ' msec')
    }

    let onSelectChange = trottle((event) => {
        console.log('onSelectChange')

        function prepareDataAndDraw (myYearFrom, myYearTo, rawData) {
            const myDataObject = {}
            rawData.forEach(el => {
                myDataObject[el.t] = el.v
            })
            drawGraph(myYearFrom, myYearTo, myDataObject)
        }

        const mySelectFrom = document.getElementById('year_from')
        const mySelectTo = document.getElementById('year_to')
        if (mySelectFrom.value > mySelectTo.value && event.target === mySelectFrom) {
            mySelectTo.value = mySelectFrom.value
        } else if (mySelectTo.value < mySelectFrom.value && event.target === mySelectTo) {
            mySelectFrom.value = mySelectTo.value
        }

        let myYearFrom = mySelectFrom.value
        let myYearTo = mySelectTo.value
        console.log(myYearFrom, myYearTo)


        if (localStorage.getItem(applicationMode) !== '1') {
            // use fetch data
            console.log('using fetch data')
            prepareDataAndDraw(myYearFrom, myYearTo, fetchJsonData[applicationMode])
        } else {
            console.log('using idb data')
            // use idb data
            if (!myIDBInstance) return
            const myTransactionRead = myIDBInstance.transaction(applicationMode, 'readonly')
            const myTable = myTransactionRead.objectStore(applicationMode)

            // Query the data
            const myIdbResult = myTable.getAll(
                IDBKeyRange.bound('' + myYearFrom + '-01-01', '' + myYearTo + '-12-31', false, false)
            )

            myIdbResult.onsuccess = () => {
                prepareDataAndDraw(myYearFrom, myYearTo, myIdbResult.result)
            }
        }


    }, SELECT_TROTTLE_TIME)

    let myStartFetching = Date.now()

    const idbPromise = new Promise((resolve, reject) => {
        // init DB
        let openRequest = window.indexedDB.open(DB_NAME, 2)
        openRequest.onupgradeneeded = (event) => {
            console.log('upgrading database')
            let db = event.target.result
            // let db = openRequest.result;
            if (!db.objectStoreNames.contains(TABLE_TEMPER)) {
                console.log('creating table', TABLE_TEMPER)
                // const TEMPER =
                db.createObjectStore(TABLE_TEMPER, {keyPath: 't'})
                // TEMPER.createIndex('IDX_YEAR', 'year')
            }
            if (!db.objectStoreNames.contains(TABLE_PREC)) {
                console.log('creationg table', TABLE_PREC)
                const PREC = db.createObjectStore(TABLE_PREC, {keyPath: 't'})
                PREC.createIndex('IDX_YEAR', 'year')
            }
        };

        openRequest.onerror = (event) => {
            // console.error('Error', event.target.result.error);
            console.error('IDB Error', event.target.errorCode)
            reject('IDB Error: ', event.target.errorCode)
        }

        openRequest.onsuccess = (event) => {
            myIDBInstance = event.target.result
            // const db = openRequest
            console.log('connection established to:', '"' + DB_NAME + '"')

            // myIDBInstance.onerror = (event) => {
            //     console.log('db error', myIDBInstance.error)
            // }

            resolve(myIDBInstance)
        };
    })

    function storeDataToIdb(tableName, jsonData) {
        // fill IDB if connection ready
        idbPromise.then((idbInstance) => {
            console.log('json data length: ', jsonData.length)
            const myTransaction = idbInstance.transaction(tableName, 'readwrite')

            const myTxTemperTableRW = myTransaction.objectStore(tableName)

            // TODO: make promise for filling IDB.
            const myStartInserting1 = Date.now()
            console.log('inserting...', tableName)
            jsonData.forEach((element) => {
                myTxTemperTableRW.put(element)
            })

            localStorage.setItem(tableName, '1')
            fetchJsonData[tableName] = undefined
            console.log('IDB inserting time: ', Date.now() - myStartInserting1, ' msec')
        })
    }

    function getYearMinMaxSlowButPrettier(jsonData) {
        const myArray = jsonData.map((el) => parseInt(el.t.substring(0, 4), 10))
        return [Math.min(...myArray), Math.max(...myArray)]
    }

    function getYearMinMax(jsonData) {
        let myYearFrom = Number.NaN
        let myYearTo = Number.NaN
        jsonData.forEach((element) => {
            const myYear = parseInt(element.t.substring(0, 4), 10)
            myYearFrom = Math.min(myYearFrom, myYear) || myYear
            myYearTo = Math.max(myYearTo, myYear) || myYear
        })
        return [myYearFrom, myYearTo]
    }

    function fetchAndStorePrecipitation() {
        // load and store precipitation
        fetch(URL_PRECIPITATION).then(
            (response) => response.json()
        ).then((jsonData) => {
            fetchLoaded[TABLE_PREC] = true
            fetchJsonData[TABLE_PREC] = jsonData

            const [myYearFrom, myYearTo] = getYearMinMax(jsonData)
            localStorage.setItem('precipYearMin', '' + myYearFrom)
            localStorage.setItem('precipYearMax', '' + myYearTo)
            setTimeout(() => storeDataToIdb(TABLE_PREC, jsonData), 0)
        })
    }

    window.addEventListener('load', function () {
        fetch(URL_TEMPERATURE).then(
            (response) => response.json()
        ).then((jsonData) => {
            fetchLoaded[TABLE_TEMPER] = true
            fetchJsonData[TABLE_TEMPER] = jsonData
            console.log('fetch time: ', Date.now() - myStartFetching, ' msec')

            const [myYearFrom, myYearTo] = getYearMinMax(jsonData)

            localStorage.setItem('temperYearMin', '' + myYearFrom)
            localStorage.setItem('temperYearMax', '' + myYearTo)

            drawGraph(myYearFrom, myYearTo, jsonData.reduce((obj, el) => (obj[el.t] = el.v, obj), {}))

            fillSelect('year_from', myYearFrom, myYearTo, myYearFrom)
            fillSelect('year_to', myYearFrom, myYearTo, myYearTo)

            setTimeout(() => storeDataToIdb(TABLE_TEMPER, jsonData), 0)
        }).then(() => {
            fetchAndStorePrecipitation()
        })

        document.getElementById('year_from').addEventListener('change', onSelectChange)
        document.getElementById('year_to').addEventListener('change', onSelectChange)
    })

    document.getElementById('clearIDB').addEventListener('click', event => {
        console.log('local storage cleanup')
        localStorage.clear()

        console.log('database ', DB_NAME, ' deleting...')

        const deleteRequest = indexedDB.deleteDatabase(DB_NAME);
        deleteRequest.onerror = function () {
            console.error("Error", deleteRequest.error)
        }

        deleteRequest.onsuccess = function () {
            console.log('database deleted')
            console.log(deleteRequest)
        }

        event.preventDefault()
    })
</script>
</body>
</html>
