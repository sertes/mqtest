<html>
<head>
    <title>MQ Test Page</title>
    <meta name="description" content="MQ test page">
    <meta name="keywords" content="mq test page">
    <meta charset="utf-8">
    <meta name="viewport" content="width=1024px, initial-scale=1">

    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
            'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
            sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /** {*/
        /*  font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;*/
        /*}*/

        * {
            box-sizing: border-box;
        }

        h1 {
            margin: 5px;
        }

        .container {
            display: flex;
        }

        .content {
            margin-left: 10px;
        }

        #button_precip, #button_temper, #button_drop_idb {
            width: 160px;
            border: 1px solid gray;
            margin: 5px;
            padding: 5px 10px;
            cursor: pointer;
            user-select: none;
        }

        #button_precip.selected, #button_temper.selected {
            background-color: lightgrey;
        }

        select {
            border: 1px solid gray;
            padding: 5px 10px;
            margin: 5px 0;
            cursor: pointer;
        }

        .graph {
            padding: 5px;
            border: 1px solid gray;
        }
    </style>

</head>
<body>
<h1>Архив метеослужбы</h1>
<div class="container">
    <div class="left">
        <div id="button_temper" class="button" tabindex="40">Температура</div>
        <div id="button_precip" class="button" tabindex="50">Осадки</div>
        <div id="button_drop_idb" class="button">DBG: RESET CACHE</div>
    </div>
    <div class="content">
        <div class="filters">
            <select id="year_from" tabindex="10">
                <option>1881</option>
            </select>
            <select id="year_to" tabindex="20">
                <option>2006</option>
            </select>
        </div>
        <canvas class="graph" height="320" width="480" id="graph" />
    </div>
</div>
<script>
    import './index.css';

    // TODO: check every requirement from MQ
    // TODO: check against NATA rules

    ///////////////////////////////////////////////////////////////////////////////
    // CONFIGURATION
    const URL_TEMPERATURE = './temperature.json?r=' + Math.random()
    const URL_PRECIPITATION = './precipitation.json?r=' + Math.random()

    const DB_NAME = 'store'
    const TABLE_TEMPER = 'temperature'
    const TABLE_PREC = 'precipitation'
    const SELECT_TROTTLE_TIME = 180 // select boxes trottle time in milliseconds

    ///////////////////////////////////////////////////////////////////////////////
    // ENTRY POINT

    window.addEventListener('load', function () {
        new Controller()
    })

    ///////////////////////////////////////////////////////////////////////////////
    // Classes

    /**
     * Data Adapter
     * @description Singleton class returning assync IDB connection
     */
    class Adapter {
        constructor() {
            if (typeof Adapter.instance === 'object') {
                return Adapter.instance
            }
            this.idbInstancePromise = undefined
            Adapter.instance = this
            return Adapter.instance
        }

        async getConnection() {
            if (typeof this.idbInstancePromise === 'undefined') {
                this.idbInstancePromise = new Promise((resolve, reject) => {
                    // init DB
                    let openRequest = window.indexedDB.open(DB_NAME, 1)
                    openRequest.onupgradeneeded = (event) => {
                        console.log('upgrading database...')
                        let db = event.target.result
                        if (!db.objectStoreNames.contains(TABLE_TEMPER)) {
                            console.log('creating table', TABLE_TEMPER)
                            db.createObjectStore(TABLE_TEMPER, {keyPath: 't'})
                        }
                        if (!db.objectStoreNames.contains(TABLE_PREC)) {
                            console.log('creationg table', TABLE_PREC)
                            db.createObjectStore(TABLE_PREC, {keyPath: 't'})
                        }
                    }

                    openRequest.onerror = (event) => {
                        console.error('IDB Error', event.target.errorCode)
                        reject('IDB Error: ', event.target.errorCode)
                    }

                    openRequest.onsuccess = (event) => {
                        console.log('connection established to:', '"' + DB_NAME + '"')
                        resolve(event.target.result)
                    }
                })
            }
            return this.idbInstancePromise
        }
    }

    class Model {
        constructor(params) {
            this.name = params.name
            this.url = params.url

            this.loaded = false
            this.storingPromise = false
            this.stored = localStorage.getItem(`${this.name}_stored`) === 'stored'
        }

        get yearMin() {
            return parseInt(localStorage.getItem(`${this.name}_YearMin`), 10) || -Infinity
        }

        set yearMin(value) {
            localStorage.setItem(`${this.name}_YearMin`, value)
        }

        get yearMax() {
            return parseInt(localStorage.getItem(`${this.name}_YearMax`), 10) || Infinity
        }

        set yearMax(value) {
            localStorage.setItem(`${this.name}_YearMax`, value)
        }

        #getYearMinMax(json) {
            let yearFrom = Infinity
            let yearTo = -Infinity
            json.forEach((element) => {
                const myYear = parseInt(element.t.substring(0, 4), 10)
                yearFrom = Math.min(yearFrom, myYear)
                yearTo = Math.max(yearTo, myYear)
            })
            return [yearFrom, yearTo]
        }

        async #storeDataToIdb(json) {
            if (this.storingPromise === false) {
                // fill IDB then IDB connection ready
                this.storingPromise = new Adapter().getConnection().then((idbInstance) => {
                    return new Promise((resolve, reject) => {
                        const myTransaction = idbInstance.transaction(this.name, 'readwrite')
                        const myTable = myTransaction.objectStore(this.name)

                        myTransaction.oncomplete = () => {
                            localStorage.setItem(`${this.name}_stored`, 'stored')
                            resolve()
                        }

                        myTransaction.onabort = () => {
                            reject(myTransaction.error)
                        }

                        const myTimer = Date.now()
                        console.log('inserting...', this.name)
                        json.forEach((element) => {
                            myTable.put(element)
                        })
                        console.log('IDB inserting time: ', Date.now() - myTimer, ' msec')
                    })
                })
            }
            return this.storingPromise
        }

        async get(yearFrom, yearTo) {
            yearFrom = yearFrom || this.yearMin
            yearTo = yearTo || this.yearMax

            const reduceFn = (obj, el) => (obj[el.t] = el.v, obj)

            // super lazy load
            if (this.stored) {
                // select from IDB
                const myIDBInstance = await new Adapter().getConnection()
                return new Promise((resolve, reject) => {
                    let myIdbFetching = Date.now()
                    const myTransactionRead = myIDBInstance.transaction(this.name, 'readonly')
                    const myTable = myTransactionRead.objectStore(this.name)
                    // Query the data
                    const myIdbResult = myTable.getAll(IDBKeyRange.bound(`${yearFrom}-01-01`, `${yearTo}-12-31`, false, false))
                    myIdbResult.onsuccess = () => {
                        console.log('IDB fetching time: ', Date.now() - myIdbFetching, ' msec')
                        resolve(myIdbResult.result.reduce(reduceFn, {}))
                    }
                })
            } else if (this.loaded === false) {
                this.loaded = fetch(this.url).then((result) => result.json())
            }

            // loading started but not ended
            return this.loaded.then((json) =>  {
                const [myYearFrom, myYearTo] = this.#getYearMinMax(json)
                this.yearMin = myYearFrom
                this.yearMax = myYearTo
                setTimeout(() => this.#storeDataToIdb(json), 500) // postpone inserting to make smoother UX
                // TODO: possible should be filtered
                return json.reduce(reduceFn, {})
            })
        }
    }

    class View {
        constructor(params) {
            this.mode = params.mode || TABLE_TEMPER
            this.modeChangeHandler = params.modeChangeHandler
            this.yearChangeHandler = params.yearChangeHandler

            document.getElementById('year_from').addEventListener('change', this.onSelectChangeHandler())
            document.getElementById('year_to').addEventListener('change', this.onSelectChangeHandler())
            document.getElementById('button_temper').addEventListener('click', this.onButtonClickHandler.bind(this, TABLE_TEMPER))
            document.getElementById('button_precip').addEventListener('click', this.onButtonClickHandler.bind(this, TABLE_PREC))
        }

        // draw graph
        drawGraph(yearFrom, yearTo, dataObject) {
            const myGraph = document.getElementById('graph')
            const myCtx = myGraph.getContext('2d')
            myCtx.clearRect(0, 0, myGraph.width, myGraph.height)
            myCtx.strokeRect(0, 0, myGraph.width, myGraph.height)

            const myLabels = utils.getYearDates(yearFrom, yearTo)
            const myValuesY = {}
            const myValuesX = []

            console.log('from', yearFrom, 'to', yearTo)

            const myPixelFactor = 1
            const myAveragingInterval = Math.round(myLabels.length / myGraph.width) * myPixelFactor

            // count min max
            let myMin = Number.NaN
            let myMax = Number.NaN
            let myAvgSum = Number.NaN
            let myCnt = 0
            const myMinMaxCount = Date.now()
            for (let i = 0; i < myLabels.length; i += 1) {
                let myValue = dataObject[myLabels[i]]
                if (typeof myValue !== 'undefined') {
                    myAvgSum = (!Number.isNaN(myAvgSum)) ? (myAvgSum + myValue) : myValue
                    myCnt += 1
                }

                if (i % myAveragingInterval === 0) {
                    myValuesX.push(myLabels[i]);

                    let myAvgValue = (myCnt !== 0) ? myAvgSum / myCnt : Number.NaN
                    if (!Number.isNaN(myAvgValue)) {
                        myValuesY[myLabels[i]] = myAvgValue
                        myMin = (!Number.isNaN(myMin)) ? Math.min(myMin, myAvgValue) : myAvgValue
                        myMax = (!Number.isNaN(myMax)) ? Math.max(myMax, myAvgValue) : myAvgValue
                    }

                    myAvgSum = Number.NaN
                    myCnt = 0
                }
            }
            console.log('minmax count time: ', Date.now() - myMinMaxCount, ' msec', 'min:', myMin, 'max:', myMax)

            //draw x axis
            myCtx.beginPath()
            myCtx.moveTo(0, getY(0))
            myCtx.lineTo(myGraph.width, getY(0))
            myCtx.stroke()

            // myCtx.font = "14px serif";
            myCtx.fillText('' + Math.round(myMax), 5, 14);
            myCtx.fillText('' + Math.round(myMin), 5, myGraph.height - 5);

            function getY(value) {
                const myStrengthFactor = myGraph.height / (myMax - myMin)
                return myGraph.height - (0 - myMin + value) * myStrengthFactor
            }

            function getX(n, count) {
                return (myGraph.width / count) * n
            }

            // let myX = 0;
            myCtx.beginPath();
            myCtx.moveTo(0, myGraph.height / 2);
            const myPlottingTime = Date.now()

            let myGapFound = true
            for (let i = 0; i < myValuesX.length; i += 1) {
                let myValue = myValuesY[myValuesX[i]]
                if(!Number.isNaN(myValue)) {
                    if (myGapFound) {
                        // myCtx.moveTo(myX += myPixelFactor, getY(myValue))
                        myCtx.moveTo(getX(i, myValuesX.length), getY(myValue))
                        myGapFound = false
                    } else {
                        myCtx.lineTo(getX(i, myValuesX.length), getY(myValue))
                        // myCtx.lineTo(myX += myPixelFactor, getY(myValue))
                    }

                } else {
                    myGapFound = true;
                    console.log('gap found at:', myValuesX[i])
                }
            }
            myCtx.stroke();
            console.log('plotting time: ', Date.now() - myPlottingTime, ' msec')
        }

        refillSelect(type, min, max, selected) {
            const mySelect = document.getElementById(type === 'yearFrom' ? 'year_from' : 'year_to')
            mySelect.length = 0 // fast remove select options
            const myFragment = document.createDocumentFragment()
            for (let i = parseInt(min, 10); i <= parseInt(max, 10); i += 1) {
                const mySelectOption = document.createElement('option')
                mySelectOption.value = mySelectOption.text = '' + i
                myFragment.appendChild(mySelectOption)
            }
            mySelect.appendChild(myFragment)
            mySelect.value = selected
        }

        onSelectChangeHandler() {
            return utils.trottle((event) => {
                const mySelectFrom = document.getElementById('year_from')
                const mySelectTo = document.getElementById('year_to')
                if (mySelectFrom.value > mySelectTo.value && event.target === mySelectFrom) {
                    mySelectTo.value = mySelectFrom.value
                } else if (mySelectTo.value < mySelectFrom.value && event.target === mySelectTo) {
                    mySelectFrom.value = mySelectTo.value
                }
                if (this.yearChangeHandler) this.yearChangeHandler(mySelectFrom.value, mySelectTo.value)
            }, SELECT_TROTTLE_TIME)
        }

        updateButons(mode) {
            if (mode === TABLE_TEMPER) {
                document.getElementById('button_temper').classList.add('selected')
                document.getElementById('button_precip').classList.remove('selected')
            } else {
                document.getElementById('button_temper').classList.remove('selected')
                document.getElementById('button_precip').classList.add('selected')
            }
        }

        onButtonClickHandler(mode) {
            if (mode === this.mode) return
            this.mode = mode
            this.updateButons(this.mode)
            if (this.modeChangeHandler) this.modeChangeHandler(this.mode)
        }
    }

    class Controller {
        temeratureModel = new Model({
            name: TABLE_TEMPER,
            url: URL_TEMPERATURE
        })

        percipitationModel = new Model({
            name: TABLE_PREC,
            url: URL_PRECIPITATION
        })

        view = new View({
            mode: TABLE_TEMPER,
            modeChangeHandler: this.modeChangeHandler.bind(this),
            yearChangeHandler: this.yearChangeHandler.bind(this)
        })

        constructor() {
            this.modeChangeHandler(TABLE_TEMPER).then(() => this.percipitationModel.get())
        }

        modeChangeHandler(mode) {
            console.log('changing mode')
            this.curModel = (mode === TABLE_TEMPER) ? this.temeratureModel : this.percipitationModel
            return this.curModel.get().then((obj) => {
                this.view.updateButons(mode)
                this.view.refillSelect('yearFrom', this.curModel.yearMin, this.curModel.yearMax, this.curModel.yearMin)
                this.view.refillSelect('yearTo', this.curModel.yearMin, this.curModel.yearMax, this.curModel.yearMax)
                this.view.drawGraph(this.curModel.yearMin, this.curModel.yearMax, obj)
            })
        }

        yearChangeHandler(yearFrom, yearTo) {
            this.curModel.get(yearFrom, yearTo).then((obj) => {
                this.view.drawGraph(yearFrom, yearTo, obj)
            })
        }
    }

    const utils = {
        trottle: function trottle(f, delay) {
            let myTrottled = false, myArgs, myContext
            function trottled() {
                if (myTrottled) {
                    myArgs = arguments
                    myContext = this
                    return
                }

                f.apply(this, arguments)
                myTrottled = true

                setTimeout(() => {
                    myTrottled = false
                    if (myArgs) {
                        trottled.apply(myContext, myArgs)
                        myContext = myArgs = null
                    }
                }, delay)
            }
            return trottled
        },
        getYearDates: function (yearFrom, yearTo) {
            yearFrom = parseInt(yearFrom, 10)
            yearTo = parseInt(yearTo, 10)
            const result = []
            const monthsDays = { 1: 31, 2: 29, 3: 31, 4: 30, 5: 31, 6: 30, 7: 31, 8: 31, 9: 30, 10: 31, 11: 30, 12: 31 }
            for (let year = yearFrom; year <= yearTo; year += 1) {
                // leap correction
                const isLeap = (0 === year % 4) && (0 !== year % 100) || (0 === year % 400)
                monthsDays[2] = (isLeap) ? 29 : 28
                for (let month = 1; month <= 12; month += 1) {
                    for (let day = 1; day <= monthsDays[month]; day += 1) {
                        result.push(`${year}-${(month >= 10) ? month : (`0${month}`)}-${(day >= 10) ? day : (`0${day}`)}`)
                    }
                }
            }
            return result
        },
    }

    ///////////////////////////////////////////////////////////////////////////////
    // DEBUG SECTION

    document.getElementById('button_drop_idb').addEventListener('click', event => {
        console.log('local storage cleanup')
        localStorage.clear()

        console.log('database ', DB_NAME, ' deleting...')

        const deleteRequest = indexedDB.deleteDatabase(DB_NAME);
        deleteRequest.onerror = function () {
            console.error("Error", deleteRequest.error)
        }

        deleteRequest.onsuccess = function () {
            console.log('database deleted')
            console.log(deleteRequest)
        }

        event.preventDefault()
    })
</script>
</body>
</html>
