<html>
<head>
    <title>MQ Test Page</title>
    <meta name="description" content="MQ test page">
    <meta name="keywords" content="mq test page">
    <meta charset="utf-8">
    <meta name="viewport" content="width=1024px, initial-scale=1">

    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
            'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
            sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /** {*/
        /*  font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;*/
        /*}*/

        * {
            box-sizing: border-box;
        }

        .container {
            display: flex;
        }

        .graph {
            padding: 5px;
            border: 1px solid gray;
            width: 480px;
            height: 320px;
        }
    </style>

</head>
<body>
<h1>Архив метеослужбы</h1>
<div class="container">
    <div class="left">
        <div><button>Температура</button></div>
        <div><button>Осадки</button></div>
    </div>
    <div class="content">
        <div class="filters">
            <select id="year_from">
                <option>1881</option>
            </select>
            <select id="year_to">
                <option>2006</option>
            </select>
        </div>
        <canvas class="graph" height="320" width="480" id="graph"></canvas>
    </div>
</div>
<div><button id="clearIDB">Clear IndexedDB</button></div>
<script>
    // TODO: check every requirement from MQ
    // TODO: check against NATA rules

    ///////////////////////////////////////////////////////////////////////////////
    // CONFIGURATION
    const DB_NAME = 'store'
    const TABLE_TEMPER = 'temperature'
    const TABLE_PREC = 'precipitation'

    let myIDB;

    function fillSelect(id, min, max, selected) {
        const mySelect = document.getElementById(id)
        mySelect.length = 0
        const myFragment = document.createDocumentFragment()
        for (let i = min; i <= max; i += 1) {
            const mySelectOption = document.createElement('option')
            mySelectOption.value = mySelectOption.text = i
            myFragment.appendChild(mySelectOption)
        }
        mySelect.appendChild(myFragment)
        mySelect.value = selected
    }

    // fill year dates
    function fillYearDates(yearFrom, yearTo) {
        // TODO: make without Date object
        const myStart = Date.now()
        const myResult = []
        let myCurrentDate = new Date(yearFrom + '-01-01')
        while (myCurrentDate.getFullYear() <= yearTo) {
            myResult.push([
                myCurrentDate.getFullYear(),
                ('0' + (myCurrentDate.getMonth() + 1)).slice(-2),
                ('0' + myCurrentDate.getDate()).slice(-2)
            ].join('-'))
            myCurrentDate.setDate(myCurrentDate.getDate() + 1)
        }
        console.log('fillYearDates time: ', Date.now() - myStart, ' msec')
        return myResult
    }

    // draw graph
    function drawGraph(yearFrom, yearTo, dataObject) {
        const myGraph = document.getElementById('graph')
        const myCtx = myGraph.getContext('2d')
        myCtx.clearRect(0, 0, myGraph.width, myGraph.height)
        myCtx.strokeRect(0, 0, myGraph.width, myGraph.height)

        const myLabels = fillYearDates(yearFrom, yearTo)
        const myValuesY = {}
        const myValuesX = []

        const myPixelFactor = 1.5
        const myAveragingInterval = Math.round(myLabels.length / myGraph.width) * myPixelFactor

        // count min max
        let myMin = Number.NaN
        let myMax = Number.NaN
        let myAvgSum = Number.NaN
        let myCnt = 0
        const myMinMaxCount = Date.now()
        for (let i = 1; i < myLabels.length; i += 1) {
            if (i % myAveragingInterval === 0) {
                myValuesX.push(myLabels[i]);

                let myAvgValue = (myCnt !== 0) ? myAvgSum / myCnt : Number.NaN
                if (myAvgValue) {
                    myValuesY[myLabels[i]] = myAvgValue
                    myMin = Math.min(myMin, myAvgValue) || myAvgValue
                    myMax = Math.max(myMax, myAvgValue) || myAvgValue
                }

                myAvgSum = Number.NaN
                myCnt = 0
            }

            let myValue = dataObject[myLabels[i]]?.['v']
            if (myValue) {
                myAvgSum = (myAvgSum) ? (myAvgSum + myValue) : myValue
                myCnt += 1
            }
        }
        console.log('minmax count time: ', Date.now() - myMinMaxCount, ' msec', 'min:', myMin, 'max:', myMax)

        //draw x axis
        myCtx.beginPath()
        myCtx.moveTo(0, getY(0))
        myCtx.lineTo(myGraph.width, getY(0))
        myCtx.stroke()

        function getY(value) {
            const myStrengthFactor = myGraph.height / (myMax - myMin)
            return (0 - myMin + value) * myStrengthFactor
        }

        let myX = 0;
        myCtx.beginPath();
        myCtx.moveTo(0, myGraph.height / 2);
        const myPlottingTime = Date.now()

        let myGapFound = true
        for (let i = 0; i < myValuesX.length; i += 1) {
            let myValue = myValuesY[myValuesX[i]]
            if(myValue) {
                if (myGapFound) {
                    myCtx.moveTo(myX += myPixelFactor, getY(myValue))
                    myGapFound = false
                } else {
                    myCtx.lineTo(myX += myPixelFactor, getY(myValue))
                }

            } else {
                myGapFound = true;
                console.log('gap found at:', myValuesX[i])
            }
        }
        myCtx.stroke();
        console.log('plotting time: ', Date.now() - myPlottingTime, ' msec')
    }

    document.getElementById('clearIDB').addEventListener('click', event => {
        console.log('database ', DB_NAME, ' deleting...')

        const deleteRequest = indexedDB.deleteDatabase(DB_NAME);
        deleteRequest.onerror = function () {
            console.error("Error", deleteRequest.error)
        }

        deleteRequest.onsuccess = function () {
            console.log('database deleted')
            console.log(deleteRequest)
        }

        event.preventDefault()
    })

    function onSelectChange(event) {
        const mySelectFrom = document.getElementById('year_from')
        const mySelectTo = document.getElementById('year_to')
        if (mySelectFrom.value > mySelectTo.value && event.target === mySelectFrom) {
            mySelectTo.value = mySelectFrom.value
        } else if (mySelectTo.value < mySelectFrom.value && event.target === mySelectTo) {
            mySelectFrom.value = mySelectTo.value
        }

        if (!myIDB) return
        ///// TODO: make new transaction for reading // DONE but doesnt help/ same request time
        const myTransactionRead = myIDB.transaction(TABLE_TEMPER, 'readonly')
        myTransactionRead.onabort = function () {
            console.log('myTransactionRead transaction error ', myTransactionRead.error)
        };

        const myTxTemperTableRead = myTransactionRead.objectStore(TABLE_TEMPER)

        myTxTemperTableRead.onerror = function (event) {
            console.log('myTxTemperTableRead table error: ', myTxTemperTableRead.error)
        }

        const myStartQuery = Date.now()
        let yearFrom = mySelectFrom.value
        let yearTo = mySelectTo.value
        // Query the data
        const get1881 = myTxTemperTableRead.getAll(
            IDBKeyRange.bound(yearFrom, yearTo, false, false)
        )

        get1881.onsuccess = function () {
            console.log('IDB query time: ', Date.now() - myStartQuery, ' msec')
            // console.log(get1881.result) // 1881

            const myDataObject = {}
            get1881.result.forEach(el => {
                Object.assign(myDataObject, el['data'])
            })
            drawGraph(yearFrom, yearTo, myDataObject)
            console.log('TOTAL TIME ', Date.now() - myStartFetching, ' msec')
        }

        // fill year dates
        // console.log(fillYearDates(1881))

        // drawGraph(jsonData)

    }

    let myStartFetching = Date.now()

    window.addEventListener('load', function () {
        console.log('page loaded')

        let myStartFetching = Date.now()
        fetch('./temperature.json?r=' + myStartFetching)
            .then((response) => {
                return response.json()
            })
            .then((jsonData) => {
                console.log('fetch time: ', Date.now() - myStartFetching, ' msec')
                // init DB
                let openRequest = window.indexedDB.open(DB_NAME, 2)

                openRequest.onupgradeneeded = (event) => {
                    console.log('upgrading database')
                    let db = event.target.result
                    // let db = openRequest.result;
                    if (!db.objectStoreNames.contains(TABLE_TEMPER)) {
                        console.log('creating table', TABLE_TEMPER)
                        // const TEMPER =
                        db.createObjectStore(TABLE_TEMPER)
                        // TEMPER.createIndex('IDX_YEAR', 'year')
                    }
                    if (!db.objectStoreNames.contains(TABLE_PREC)) {
                        console.log('creationg table', TABLE_PREC)
                        const PREC = db.createObjectStore(TABLE_PREC)
                        PREC.createIndex('IDX_YEAR', 'year')
                    }
                };

                openRequest.onerror = (event) => {
                    // console.error('Error', event.target.result.error);
                    console.error('Error', event.target.errorCode)
                }

                openRequest.onsuccess = (event) => {
                    myIDB = event.target.result
                    // const db = openRequest
                    console.log('connection established to: "', DB_NAME, '"')

                    console.log('json data length: ', jsonData.length)

                    // myIDB.onerror = (event) => {
                    //     console.log('db error', myIDB.error)
                    // }

                    const tx = myIDB.transaction(TABLE_TEMPER, 'readwrite')
                    tx.onabort = function () {
                        console.log('transaction error ', tx.error)
                    }

                    const myTxTemperTableRW = tx.objectStore(TABLE_TEMPER)

                    myTxTemperTableRW.onerror = function (event) {
                        console.log('temperature RW transaction table error: ', myTxTemperTableRW.error)
                    }

                    const myStartInserting1 = Date.now()
                    console.log('inserting...')
                    jsonData.forEach((element) => {
                        myTxTemperTableRW.add(element.v, element.t)
                        // myTxTemperTableRW.put(element.v, parseInt(element.t.split('-').join(), 10))
                    })
                    console.log('IDB inserting time: ', Date.now() - myStartInserting1, ' msec')
                    return


                    // {
                    //      '1881': {
                    //          'year': '1881',
                    //          'data': {
                    //              '1881-01-01': {'t': '1881-01-01', 'v': 2.5}
                    //              '1881-01-02': {'t': '1881-01-02', 'v': 3.0}
                    //              '1881-01-03': {'t': '1881-01-03', 'v': 4.5}
                    //              ......
                    //          }
                    //      },
                    // }
                    const idbTemperData = {}

                    // prepare data for IDB
                    jsonData.forEach((element) => {
                        // element year
                        element.year = parseInt(element.t.substring(0, 4), 10)
                        idbTemperData[element.year] = idbTemperData[element.year] || { year: element.year, data: {}}
                        idbTemperData[element.year]['data'][element.t] = element
                    })

                    // console.log(idbTemperData)

                    // prepare for the first FAST run and draw graph
                    // {
                    //    '1881-01-01': {'t': '1881-01-01', 'v': 2.5}
                    //    '1881-01-02': {'t': '1881-01-02', 'v': 3.0}
                    //    '1881-01-03': {'t': '1881-01-03', 'v': 4.5}
                    //    ......
                    // }
                    const myDataObject = {}
                    let myYearFrom = Number.NaN
                    let myYearTo = Number.NaN
                    Object.entries(idbTemperData).forEach(el => {
                        const [year, value] = el
                        myYearFrom = Math.min(myYearFrom, parseInt(year, 10)) || year
                        myYearTo = Math.max(myYearTo, parseInt(year, 10)) || year
                        Object.assign(myDataObject, value['data']);
                    })
                    drawGraph(myYearFrom, myYearTo, myDataObject)
                    console.log('min dataset year:', myYearFrom)
                    console.log('max dataset year:', myYearTo)

                    const myStartPopulatingSelects = Date.now()
                    console.log('populating selects...')
                    fillSelect('year_from', myYearFrom, myYearTo, myYearFrom)
                    fillSelect('year_to', myYearFrom, myYearTo, myYearTo)
                    console.log('populating selects time: ', Date.now() - myStartPopulatingSelects, ' msec')

                    console.log('TOTAL TIME ', Date.now() - myStartFetching, ' msec')
                    console.log('ULTRA TOTAL TIME ', Date.now() - document.myStartTime, ' msec')

                    const myStartInserting = Date.now()
                    console.log('inserting...')
                    Object.entries(idbTemperData).forEach(el => {
                        const [, value] = el
                        myTxTemperTableRW.put(value)
                    })
                    console.log('IDB inserting time: ', Date.now() - myStartInserting, ' msec')

                    // Close the db when the transaction is done
                    // tx.oncomplete = function() {
                    //     db.close();
                    // };

                };
            })

        document.getElementById('year_from').addEventListener('change', onSelectChange)
        document.getElementById('year_to').addEventListener('change', onSelectChange)

    });
</script>
</body>
</html>
